<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parallel loops · FLoops</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><script src="../../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FLoops</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">FLoops.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../sequential/">Sequential loops</a></li><li class="is-active"><a class="tocitem" href>Parallel loops</a><ul class="internal"><li><a class="tocitem" href="#Independent-execution"><span>Independent execution</span></a></li><li><a class="tocitem" href="#Reduction-using-@reduce-acc-x-syntax"><span>Reduction using <code>@reduce acc ⊗= x</code> syntax</span></a></li><li><a class="tocitem" href="#Combining-explicit-sequential-reduction-results-using-@combine"><span>Combining explicit sequential reduction results using <code>@combine</code></span></a></li><li><a class="tocitem" href="#Advanced:-Unifying-sequential-and-cross-basecase-reductions"><span>Advanced: Unifying sequential and cross-basecase reductions</span></a></li><li><a class="tocitem" href="#local-buffer"><span>Local buffers using <code>@init</code></span></a></li><li><a class="tocitem" href="#Executing-code-at-the-end-of-basecase"><span>Executing code at the end of basecase</span></a></li><li><a class="tocitem" href="#Advanced:-Complex-reduction-with-@reduce()-do-syntax"><span>Advanced: Complex reduction with <code>@reduce() do</code> syntax</span></a></li><li><a class="tocitem" href="#Control-flow-syntaxes"><span>Control flow syntaxes</span></a></li><li><a class="tocitem" href="#tutorials-executor"><span>Executors</span></a></li><li><a class="tocitem" href="#floop-and-mapreduce"><span>Advanced: Relation to <code>mapreduce</code></span></a></li></ul></li></ul></li><li><span class="tocitem">How-to guides</span><ul><li><a class="tocitem" href="../../howto/parallel/">How to do <em>X</em> in parallel?</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../reference/api/">API</a></li><li><a class="tocitem" href="../../reference/syntax/">Syntax</a></li><li><a class="tocitem" href="../../reference/reduction/">Parallelizable reduction (WIP)</a></li></ul></li><li><span class="tocitem">Explanation</span><ul><li><a class="tocitem" href="../../explanation/faq/">FAQ</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Parallel loops</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parallel loops</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaFolds/FLoops.jl/blob/master/docs/src/tutorials/parallel.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorials-parallel"><a class="docs-heading-anchor" href="#tutorials-parallel">Parallel loops</a><a id="tutorials-parallel-1"></a><a class="docs-heading-anchor-permalink" href="#tutorials-parallel" title="Permalink"></a></h1><p><code>@floop</code> supports parallel loops not only for side-effect (as in <code>Threads.@threads</code>) but also for complex reductions using the optional <code>@combine</code> and <code>@reduce</code> syntax.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This tutorial can be read without reading the subsections with &quot;Advanced:&quot; prefix.</p></div></div><p>If you already know how <code>mapreduce</code> works,  <a href="#floop-and-mapreduce">Relation to <code>mapreduce</code></a> may be the best first step for understanding the <code>@floop</code> syntax.</p><h2 id="Independent-execution"><a class="docs-heading-anchor" href="#Independent-execution">Independent execution</a><a id="Independent-execution-1"></a><a class="docs-heading-anchor-permalink" href="#Independent-execution" title="Permalink"></a></h2><p>For in-place update operations (i.e., <code>Threads.@threads</code>-like operations), you can use <code>@floop ThreadedEx() for</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; function floop_map!(f, ys, xs, ex = ThreadedEx())
           @floop ex for i in eachindex(ys, xs)
               @inbounds ys[i] = f(xs[i])
           end
           return ys
       end;

julia&gt; floop_map!(x -&gt; x + 1, zeros(3), 1:3)
3-element Vector{Float64}:
 2.0
 3.0
 4.0</code></pre><h2 id="Reduction-using-@reduce-acc-x-syntax"><a class="docs-heading-anchor" href="#Reduction-using-@reduce-acc-x-syntax">Reduction using <code>@reduce acc ⊗= x</code> syntax</a><a id="Reduction-using-@reduce-acc-x-syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Reduction-using-@reduce-acc-x-syntax" title="Permalink"></a></h2><p>For a parallel algorithm that requires reductions, you can use <code>@reduce acc ⊗= x</code> syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; @floop for (x, y) in zip(1:3, 1:2:6)
           a = x + y
           b = x - y
           @reduce s += a
           @reduce t += b
       end
       (s, t)
(15, -3)</code></pre><h2 id="Combining-explicit-sequential-reduction-results-using-@combine"><a class="docs-heading-anchor" href="#Combining-explicit-sequential-reduction-results-using-@combine">Combining explicit sequential reduction results using <code>@combine</code></a><a id="Combining-explicit-sequential-reduction-results-using-@combine-1"></a><a class="docs-heading-anchor-permalink" href="#Combining-explicit-sequential-reduction-results-using-@combine" title="Permalink"></a></h2><p>FLoops.jl parallelizes a given loop by dividing the iteration space into <em>basecases</em> and then execute the serial reduction on each basecase.  These sub-results are combined using the function specified by <code>@combine</code> or <code>@reduce</code> syntax.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Exactly how the executor schedules the basecases and the computation for combining them depends on the type (e.g., threads/GPU/distributed) and the scheduling options.  However, the loop using <code>@floop</code> works with all of them provided that <code>@combine</code> and <code>@reduce</code> define associative function.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; pidigits = string(BigFloat(π; precision = 2^20))[3:end];

julia&gt; @floop begin
           @init hist = zeros(Int, 10)
           for char in pidigits
               n = char - &#39;0&#39;
               hist[n+1] += 1
           end
           @combine hist .+= _  # combine two histograms
       end
       hist
10-element Vector{Int64}:
 31559
 31597
 31392
 31712
 31407
 31835
 31530
 31807
 31469
 31345</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Above example uses string to show that FLoops.jl (and also other JuliaFolds packages) support strings.  But this is of course not a very good format for playing with the digits of pi.</p></div></div><p>We use syntax <code>@floop begin ... end</code> rather than <code>@floop for ... end</code> as the former has the room for placing <code>@combine</code> after the <code>for</code> loop.  The syntaxes</p><pre><code class="nohighlight hljs">@combine acc ⊗= _
@combine acc = _ ⊗ _</code></pre><p>specify that the reduction results are combined using the binary operator <code>⊗</code> (e.g., <code>⊗ = (a, b) -&gt; a .+ b</code> in the above code).  Suppose that we have <code>acc₁</code> as the result of the reduction named <code>acc</code> for the first basecase and <code>acc₂</code> for the second basecase.  These results are combined using</p><pre><code class="nohighlight hljs">acc₁ ⊗ acc₂</code></pre><p>This result is combined with the other reduction results from the adjacent (combined) results using the function <code>⊗</code> until we have the single result corresponding to the reduction <code>acc</code> of entire iteration space.</p><p>Note that initialization must be prefixed by <code>@init</code>.  This is for signifying that this initialization is local to the base case.  In particular, the initialization may (and typically does) happen multiple times since there are multiple basecases executed on different Julia tasks.</p><p>Only the variables specified by <code>@init</code> can be <code>@combine</code>d.  However, not all <code>@init</code>&#39;ed variables have to be combined.  For example, <code>@init</code> can be used for allocating local buffer for intermediate computation.  See: <a href="#local-buffer">Local buffers using <code>@init</code></a>.</p><h2 id="Advanced:-Unifying-sequential-and-cross-basecase-reductions"><a class="docs-heading-anchor" href="#Advanced:-Unifying-sequential-and-cross-basecase-reductions">Advanced: Unifying sequential and cross-basecase reductions</a><a id="Advanced:-Unifying-sequential-and-cross-basecase-reductions-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced:-Unifying-sequential-and-cross-basecase-reductions" title="Permalink"></a></h2><p>To accumulate numbers into a vector, we can use <code>push!</code> in the basecase and combine the vectors from different basecases using <code>append!</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; @floop begin
           @init odds = Int[]
           @init evens = Int[]
           for x in 1:5
               if isodd(x)
                   push!(odds, x)
               else
                   push!(evens, x)
               end
           end
           @combine odds = append!(_, _)
           @combine evens = append!(_, _)
       end
       (odds, evens)
([1, 3, 5], [2, 4])</code></pre><p>Although this code works without an issue, it is redundant to use <code>push!</code> and <code>append!</code> in this example.  Since <code>push!(xs, x)</code> and <code>append!(xs, [x])</code> are equivalent, these functions are quite similar.  The intermediate value <code>[x]</code> is referred to as a <em>singleton solution</em> because it is the value that would be used if the input collection to the <code>for</code> loop contain only one item.</p><p>Indeed, once we have the singleton solution, we can simplify the above code by using the syntax</p><pre><code class="nohighlight hljs">@reduce acc = op(init, input)</code></pre><p>The expression <code>init</code> in the first argument position specifies how to initialize the reduction result <code>acc</code>.  The expression <code>input</code> specifies the value defined in the loop body which is accumulated into the reduction result <code>acc</code>.  The current accumulation state <code>acc</code> is updated by</p><pre><code class="nohighlight hljs">acc = op(acc, input)</code></pre><p>Using this notation, the above code can be simplified to</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; @floop for x in 1:5
           ys = [x]  # &quot;singleton solution&quot;
           if isodd(x)
               @reduce odds = append!(Int[], ys)
           else
               @reduce evens = append!(Int[], ys)
           end
       end
       (odds, evens)
([1, 3, 5], [2, 4])</code></pre><pre><code class="language-julia-repl hljs">julia&gt; let
           odds = Int[]   # \___  The expression in the first argument is
           evens = Int[]  # /     used for the initialization
           for x in 1:5
               ys = [x]
               if isodd(x)
                   odds = append!(odds, ys)
                   #             -----
                   #             LHS `odds` inserted to the first argument
               else
                   evens = append!(evens, ys)
                   #             -----
                   #             LHS `evens` inserted to the first argument
               end
           end
           (odds, evens)
       end
([1, 3, 5], [2, 4])</code></pre><h3 id="Advanced:-Handling-unknown-element-types"><a class="docs-heading-anchor" href="#Advanced:-Handling-unknown-element-types">Advanced: Handling unknown element types</a><a id="Advanced:-Handling-unknown-element-types-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced:-Handling-unknown-element-types" title="Permalink"></a></h3><p>In the above code, we assumed that we know the type of the elements that are accumulated into a vector.  However, when writing generic code, it is often impossible to know the element types in advance.  We can use BangBang.jl and MicroCollections.jl to create a vector of items with unknown types in such a way that the compiler can optimize very well.</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; using BangBang  # for `append!!`

julia&gt; using MicroCollections  # for `EmptyVector` and `SingletonVector`

julia&gt; @floop for x in 1:5
           ys = SingletonVector(x)
           if isodd(x)
               @reduce odds = append!!(EmptyVector(), ys)
           else
               @reduce evens = append!!(EmptyVector(), ys)
           end
       end
       (odds, evens)
([1, 3, 5], [2, 4])</code></pre><h3 id="Advanced:-Initialization-with-@reduce(acc-init-op-x)-syntax"><a class="docs-heading-anchor" href="#Advanced:-Initialization-with-@reduce(acc-init-op-x)-syntax">Advanced: Initialization with <code>@reduce(acc = init op x)</code> syntax</a><a id="Advanced:-Initialization-with-@reduce(acc-init-op-x)-syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced:-Initialization-with-@reduce(acc-init-op-x)-syntax" title="Permalink"></a></h3><p>When <code>op</code> is a binary operator, the infix syntax <code>acc = init op x</code> can also be used:</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; @floop for (x, y) in zip(1:3, 1:2:6)
           a = x + y
           b = x - y
           @reduce(s = 0im + a, t = 0im + b)
       end
       (s, t)
(15 + 0im, -3 + 0im)</code></pre><p><strong>NOTE</strong>: In the above examples, statements like <code>odds = append!!(EmptyVector(), ys)</code> and <code>s = 0im + a</code> are <em>not</em> evaluated for each iteration.  These statements as-is are evaluated only for the first iteration (for each basecase) and then the expressions where the first argument is replaced by the corresponding LHS, i.e., <code>odds = append!!(odds, ys)</code> and <code>s = s + a</code>, are evaluated for the bulk of the loop.</p><h2 id="local-buffer"><a class="docs-heading-anchor" href="#local-buffer">Local buffers using <code>@init</code></a><a id="local-buffer-1"></a><a class="docs-heading-anchor-permalink" href="#local-buffer" title="Permalink"></a></h2><p><code>@init</code> can be used without the reduction syntaxes.  It is useful when some basecase-local buffers are required (for avoiding data races):</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; ys = zeros(5);

julia&gt; @floop begin
           @init buffer = zeros(100)
           for i in 1:5
               buffer .= sin.(i .* range(0, pi; length = length(buffer)))
               ys[i] = sum(buffer)
           end
       end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>@init</code> can also be used inside of the <code>for</code> loop body with the <code>@floop for</code> syntax as in</p><pre><code class="language-julia hljs">@floop for i in 1:5
    @init buffer = zeros(100)
    buffer .= sin.(i .* range(0, pi; length = length(buffer)))
    ys[i] = sum(buffer)
end</code></pre><p>However, <code>@floop begin ... end</code> syntax is recommended.</p></div></div><h2 id="Executing-code-at-the-end-of-basecase"><a class="docs-heading-anchor" href="#Executing-code-at-the-end-of-basecase">Executing code at the end of basecase</a><a id="Executing-code-at-the-end-of-basecase-1"></a><a class="docs-heading-anchor-permalink" href="#Executing-code-at-the-end-of-basecase" title="Permalink"></a></h2><p>On GPU, the reduction result must be an immutable value (and not contain GC-manged objects).  Thus, we can use <code>SVector</code> for a histogram with a small number of bins.  However, indexing update on <code>SVector</code> is very inefficient compared to <code>MVector</code>.  Thus, it is better to execute the basecase reduction using <code>MVector</code> while the cross-basecase reduction uses <code>SVector</code>.  This transformation be done by inserting the code after the <code>for</code> loop and before the <code>@combine</code> expression.</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; using StaticArrays

julia&gt; pidigits = string(BigFloat(π; precision = 2^20))[3:end];

julia&gt; @floop begin
           @init buf = zero(MVector{10,Int32})
           for char in pidigits
               n = char - &#39;0&#39;
               buf[n+1] += 1
           end
           hist = SVector(buf)
           @combine hist .+= _
       end
       hist
10-element SVector{10, Int32} with indices SOneTo(10):
 31559
 31597
 31392
 31712
 31407
 31835
 31530
 31807
 31469
 31345</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To run this on GPU, specific executor library like FoldsCUDA.jl has to be used.  Furthermore, <code>pidigits</code> has to be transformed into a GPU-compatible format (e.g., <code>CuVector{Int8}</code>).</p></div></div><h2 id="Advanced:-Complex-reduction-with-@reduce()-do-syntax"><a class="docs-heading-anchor" href="#Advanced:-Complex-reduction-with-@reduce()-do-syntax">Advanced: Complex reduction with <code>@reduce() do</code> syntax</a><a id="Advanced:-Complex-reduction-with-@reduce()-do-syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced:-Complex-reduction-with-@reduce()-do-syntax" title="Permalink"></a></h2><p>For more complex reduction, use <code>@reduce() do</code> syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; @floop for (i, v) in pairs([0, 1, 3, 2]), (j, w) in pairs([3, 1, 5])
           d = abs(v - w)
           @reduce() do (dmax = -1; d), (imax = 0; i), (jmax = 0; j)
               if isless(dmax, d)
                   dmax = d
                   imax = i
                   jmax = j
               end
           end
       end
       (dmax, imax, jmax)
(5, 1, 3)</code></pre><h3 id="Advanced:-How-to-read-a-loop-with-@reduce()-do-syntax"><a class="docs-heading-anchor" href="#Advanced:-How-to-read-a-loop-with-@reduce()-do-syntax">Advanced: How to read a loop with <code>@reduce() do</code> syntax</a><a id="Advanced:-How-to-read-a-loop-with-@reduce()-do-syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced:-How-to-read-a-loop-with-@reduce()-do-syntax" title="Permalink"></a></h3><p>When reading code with <code>@reduce() do</code>, a quick way to understand it is to mentally comment out the line with <code>@reduce() do</code> and the corresponding <code>end</code>.  To get a full picture, move the initialization parts (in the above example, <code>dmax = -1</code>, <code>imax = 0</code>, and <code>jmax = 0</code>) to outside <code>for</code> loop:</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; let
           dmax = -1  # -+
           imax = 0   #  | initializers
           jmax = 0   # -+
           for (i, v) in pairs([0, 1, 3, 2]), (j, w) in pairs([3, 1, 5])
               d = abs(v - w)
               if isless(dmax, d)  # -+
                   dmax = d        #  | `do` block body
                   imax = i        #  |
                   jmax = j        #  |
               end                 # -+
           end
           (dmax, imax, jmax)
       end
(5, 1, 3)</code></pre><p>This exact transformation is used for defining the sequential basecase.  Consecutive basecases are combined using the code in the <code>do</code> block body.</p><h2 id="Control-flow-syntaxes"><a class="docs-heading-anchor" href="#Control-flow-syntaxes">Control flow syntaxes</a><a id="Control-flow-syntaxes-1"></a><a class="docs-heading-anchor-permalink" href="#Control-flow-syntaxes" title="Permalink"></a></h2><p>Control flow syntaxes such as <code>continue</code>, <code>break</code>, <code>return</code>, and <code>@goto</code> work with parallel loops:</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; @floop for x in 1:10
           y = 2x
           @reduce() do (s; y)
               s = y
           end
           x == 3 &amp;&amp; break
       end
       s
6</code></pre><p><code>@reduce</code> can be used multiple times in a loop body</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; @floop for (i, v) in pairs([0, 1, 3, 2])
           y = 2v
           @reduce() do (ymax; y), (imax; i)
               if isless(ymax, y)
                   ymax = y
                   imax = i
               end
           end
           @reduce() do (ymin; y), (imin; i)
               if isless(y, ymin)
                   ymin = y
                   imin = i
               end
           end
       end
       (ymax, imax), (ymin, imin)
((6, 3), (0, 1))</code></pre><h2 id="tutorials-executor"><a class="docs-heading-anchor" href="#tutorials-executor">Executors</a><a id="tutorials-executor-1"></a><a class="docs-heading-anchor-permalink" href="#tutorials-executor" title="Permalink"></a></h2><p><code>@floop</code> takes optional executor argument to specify an execution strategies and the parameters of the strategy:</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; function demo(executor)
           @floop executor for x in 1:10
               @reduce(s += x)
           end
           return s
       end;

julia&gt; demo(SequentialEx(simd = Val(true)))
55

julia&gt; demo(ThreadedEx(basesize = 2))
55

julia&gt; demo(DistributedEx(threads_basesize = 2))
55</code></pre><p>This is in particular useful for the trick to <a href="https://juliafolds.github.io/data-parallelism/howto/faq/#set-nthreads-at-run-time">&quot;change&quot; the number of threads without restarting <code>julia</code> using <code>basesize</code> option</a>.</p><p>JuliaFolds provides additional executors:</p><ul><li><a href="https://github.com/JuliaFolds/FoldsThreads.jl">FoldsThreads.jl</a> provides a rich set of thread-based executors.</li><li><a href="https://github.com/JuliaFolds/FoldsCUDA.jl">FoldsCUDA.jl</a> provides <code>CUDAEx</code> for executing the parallel loop on GPU.</li></ul><h2 id="floop-and-mapreduce"><a class="docs-heading-anchor" href="#floop-and-mapreduce">Advanced: Relation to <code>mapreduce</code></a><a id="floop-and-mapreduce-1"></a><a class="docs-heading-anchor-permalink" href="#floop-and-mapreduce" title="Permalink"></a></h2><p>If you know are familar with functional style data parallel API and already know <code>mapreduce(f, op, xs; init)</code> works, it is worth noting that <code>@floop</code> is, <em>as a very rough approximation</em>, a way to invoke <code>acc = mapreduce(f, op, xs; init)</code> with a custom syntax</p><pre><code class="language-julia hljs">@floop for x in xs
    y = f(x)
    @reduce acc = op(init, y)
end</code></pre><p>or</p><pre><code class="language-julia hljs">@floop begin
    @init acc = init
    for x in xs
        y = f(x)
        acc = op(acc, y)
    end
    @combine acc = op(_, _)
end</code></pre><p>However, as explained above, <code>@floop</code> supports various constructs that are not directly supported by <code>mapreduce</code>.  To fully cover the semantics of <code>@floop</code> in a functional manner, the extended reduction (&quot;fold&quot;) protocol of <a href="https://github.com/JuliaFolds/Transducers.jl">Transducers.jl</a> is required.  In fact, FLoops.jl is simply a syntax sugar for invoking the reductions defined in Transducers.jl.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sequential/">« Sequential loops</a><a class="docs-footer-nextpage" href="../../howto/parallel/">How to do <em>X</em> in parallel? »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Wednesday 2 February 2022 06:07">Wednesday 2 February 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
