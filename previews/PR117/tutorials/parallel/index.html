<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parallel loops · FLoops</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><script src="../../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FLoops</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">FLoops.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../sequential/">Sequential loops</a></li><li class="is-active"><a class="tocitem" href>Parallel loops</a><ul class="internal"><li><a class="tocitem" href="#Independent-execution"><span>Independent execution</span></a></li><li><a class="tocitem" href="#Reduction-using-@reduce-acc-x-syntax"><span>Reduction using <code>@reduce acc ⊗= x</code> syntax</span></a></li><li><a class="tocitem" href="#Combining-explicit-sequential-reduction-results-using-@combine"><span>Combining explicit sequential reduction results using <code>@combine</code></span></a></li><li><a class="tocitem" href="#Advanced:-Understanding-@combine-in-terms-of-mapreduce"><span>Advanced: Understanding <code>@combine</code> in terms of <code>mapreduce</code></span></a></li><li><a class="tocitem" href="#Advanced:-Unifying-sequential-and-cross-basecase-reductions"><span>Advanced: Unifying sequential and cross-basecase reductions</span></a></li><li><a class="tocitem" href="#local-buffer"><span>Local buffers using <code>@init</code></span></a></li><li><a class="tocitem" href="#simple-completebasecase"><span>Executing code at the end of basecase</span></a></li><li><a class="tocitem" href="#Advanced:-Complex-reduction-with-@reduce()-do-syntax"><span>Advanced: Complex reduction with <code>@reduce() do</code> syntax</span></a></li><li><a class="tocitem" href="#Control-flow-syntaxes"><span>Control flow syntaxes</span></a></li><li><a class="tocitem" href="#tutorials-executor"><span>Executors</span></a></li><li><a class="tocitem" href="#floop-and-mapreduce"><span>Advanced: Relation to <code>mapreduce</code></span></a></li></ul></li></ul></li><li><span class="tocitem">How-to guides</span><ul><li><a class="tocitem" href="../../howto/parallel/">How to do <em>X</em> in parallel?</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../reference/api/">API</a></li><li><a class="tocitem" href="../../reference/syntax/">Syntax</a></li><li><a class="tocitem" href="../../reference/reduction/">Parallelizable reduction (WIP)</a></li></ul></li><li><span class="tocitem">Explanation</span><ul><li><a class="tocitem" href="../../explanation/faq/">FAQ</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Parallel loops</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parallel loops</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaFolds/FLoops.jl/blob/master/docs/src/tutorials/parallel.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorials-parallel"><a class="docs-heading-anchor" href="#tutorials-parallel">Parallel loops</a><a id="tutorials-parallel-1"></a><a class="docs-heading-anchor-permalink" href="#tutorials-parallel" title="Permalink"></a></h1><p><code>@floop</code> supports parallel loops not only for side-effect (as in <code>Threads.@threads</code>) but also for complex reductions using the <code>@combine</code> and <code>@reduce</code> macros.</p><p>If you already know how <code>mapreduce</code> works,  <a href="#floop-and-mapreduce">Relation to <code>mapreduce</code></a> may be the best first step for understanding the <code>@floop</code> syntax.</p><ul><li><a href="#tutorials-parallel">Parallel loops</a></li><li class="no-marker"><ul><li><a href="#Independent-execution">Independent execution</a></li><li><a href="#Reduction-using-@reduce-acc-x-syntax">Reduction using <code>@reduce acc ⊗= x</code> syntax</a></li><li><a href="#Combining-explicit-sequential-reduction-results-using-@combine">Combining explicit sequential reduction results using <code>@combine</code></a></li><li><a href="#Advanced:-Understanding-@combine-in-terms-of-mapreduce">Advanced: Understanding <code>@combine</code> in terms of <code>mapreduce</code></a></li><li><a href="#Advanced:-Unifying-sequential-and-cross-basecase-reductions">Advanced: Unifying sequential and cross-basecase reductions</a></li><li class="no-marker"><ul><li><a href="#Handling-unknown-element-types">Handling unknown element types</a></li><li><a href="#Initialization-with-@reduce(acc-init-op-x)-syntax">Initialization with <code>@reduce(acc = init op x)</code> syntax</a></li></ul></li><li><a href="#local-buffer">Local buffers using <code>@init</code></a></li><li><a href="#simple-completebasecase">Executing code at the end of basecase</a></li><li><a href="#Advanced:-Complex-reduction-with-@reduce()-do-syntax">Advanced: Complex reduction with <code>@reduce() do</code> syntax</a></li><li><a href="#Control-flow-syntaxes">Control flow syntaxes</a></li><li><a href="#tutorials-executor">Executors</a></li><li><a href="#floop-and-mapreduce">Advanced: Relation to <code>mapreduce</code></a></li></ul></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This tutorial can be read without reading the subsections with &quot;Advanced:&quot; prefix.</p></div></div><h2 id="Independent-execution"><a class="docs-heading-anchor" href="#Independent-execution">Independent execution</a><a id="Independent-execution-1"></a><a class="docs-heading-anchor-permalink" href="#Independent-execution" title="Permalink"></a></h2><p>For in-place update operations (i.e., <code>Threads.@threads</code>-like operations), you can use <code>@floop ThreadedEx() for</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; function floop_map!(f, ys, xs, ex = ThreadedEx())
           @floop ex for i in eachindex(ys, xs)
               @inbounds ys[i] = f(xs[i])
           end
           return ys
       end;

julia&gt; floop_map!(x -&gt; x + 1, zeros(3), 1:3)
3-element Vector{Float64}:
 2.0
 3.0
 4.0</code></pre><h2 id="Reduction-using-@reduce-acc-x-syntax"><a class="docs-heading-anchor" href="#Reduction-using-@reduce-acc-x-syntax">Reduction using <code>@reduce acc ⊗= x</code> syntax</a><a id="Reduction-using-@reduce-acc-x-syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Reduction-using-@reduce-acc-x-syntax" title="Permalink"></a></h2><p>For a parallel algorithm that requires reductions, you can use <code>@reduce acc ⊗= x</code> syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; @floop for (x, y) in zip(1:3, 1:2:6)
           a = x + y
           b = x - y
           @reduce s += a
           @reduce t += b
       end
       (s, t)
(15, -3)</code></pre><h2 id="Combining-explicit-sequential-reduction-results-using-@combine"><a class="docs-heading-anchor" href="#Combining-explicit-sequential-reduction-results-using-@combine">Combining explicit sequential reduction results using <code>@combine</code></a><a id="Combining-explicit-sequential-reduction-results-using-@combine-1"></a><a class="docs-heading-anchor-permalink" href="#Combining-explicit-sequential-reduction-results-using-@combine" title="Permalink"></a></h2><p>FLoops.jl parallelizes a given loop by dividing the iteration space into <em>basecases</em> and then execute the serial reduction on each basecase.  These sub-results are combined using the function specified by <code>@combine</code> or <code>@reduce</code> syntax.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Exactly how the executor schedules the basecases and the computation for combining them depends on the type (e.g., threads/GPU/distributed) and the scheduling options.  However, the loop using <code>@floop</code> works with all of them provided that <code>@combine</code> and <code>@reduce</code> define associative function.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; pidigits = string(BigFloat(π; precision = 2^20))[3:end];

julia&gt; @floop begin
           @init hist = zeros(Int, 10)  # (1) initialization
           for char in pidigits         # (2) basecase
               n = char - &#39;0&#39;
               hist[n+1] += 1
           end
           @combine hist .= hist .+ _   # (3) combine
           # Or, use a short hand notation:
           #     @combine hist .= _
       end
       hist
10-element Vector{Int64}:
 31559
 31597
 31392
 31712
 31407
 31835
 31530
 31807
 31469
 31345</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Above example uses string to show that FLoops.jl (and also other JuliaFolds packages) support strings.  But this is of course not a very good format for playing with the digits of pi.</p></div></div><p><em>Conceptually</em>, this produces a program that acts like (but is more optimized than) the following code:</p><pre><code class="language-julia hljs"># `chunks` is prepared such that:
@assert pidigits == reduce(vcat, chunks)
# i.e., pidigits == [chunks[1]; chunks[2]; ...; chunks[end]]

hists = Vector{Any}(undef, length(chunks))
@sync for (i, pidigitsᵢ) in enumerate(chunks)
    @spawn begin
        local hist = zeros(Int, 10)   # (1) initialization
        for char in pidigitsᵢ         # (2) basecase
            n = char - &#39;0&#39;
            hist[n+1] += 1
        end
        hists[i] = hist               # &quot;sub-solution&quot; of this basecase
    end
end
hist = hists[1]
for hist′ in hists[2:end]
    hist .= hist .+ hist′             # (3) combine the sub-solutions
end</code></pre><p>(1) The basecase-local accumulators are initialized using the <a href="../../reference/api/#FLoops.@init"><code>@init</code></a> statements.</p><p>(2) Each basecase loop is executed with its own local accumulators.</p><p>(3) The sub-solutions <code>hists</code> are combined using the expression specified by <code>@combine</code>.  In the above pseudo code, given the expression <code>hist .= hist .+ _</code> (or equivalently <code>hist .+= _</code>), the symbol <code>hist</code> is substituted by the sub-solution <code>hist</code> of the first basecase and the symbol <code>_</code> is substituted by the sub-solution <code>hist</code> of the second basecase.  Evaluation of this expression produces a sub-solution <code>hist</code> combining the first and the second basecases. The sub-solution of the third and later basecases are combined into <code>hist</code> using the same procedure.</p><p>In general, the expression</p><pre><code class="language-julia hljs">@combine acc = op(acc, _)</code></pre><p>indicates that a sub-solution <code>acc</code> computed for a certain subset of the input collection (e.g., <code>pidigits</code> in the example) is combined with the sub-solution <code>acc_right</code> using</p><pre><code class="language-julia hljs">acc = op(acc, acc_right)</code></pre><p>The binary function/operator <code>op</code> must be <a href="https://en.wikipedia.org/wiki/Associative_property">associative</a>.  However, <code>op</code> does not have to be side-effect-free.  In fact, if invoking in-place <code>op</code> on the sob-solutions does not cause thread safety issues, there is no problem in using in-place mutation.  For example, the above usage of <code>@combine hist .= hist .+ _</code> is correct because <code>hist</code> is created for each basecase; i.e., no combine step can mutate the vector <code>hist</code> while other combine step tries to read from or write to the same vector.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>All three pieces of the above <code>@floop begin ... end</code> code (i.e., (1) <code>@init ...</code>, (2) <code>for</code>-loop body, and (3) <code>@combine ...</code>) <em>may</em> (and likely will) be executed concurrently.  Thus, <strong>they must be written in such a way that concurrent execution in <em>arbitrary number</em> of tasks is correct</strong> (e.g., no data race is possible).  In particular, the above pseudo code is inaccurate in that it executes the <code>@combine</code> expression serially.  This is typically not guaranteed by the <a href="#tutorials-executor">executor</a> provided by JuliaFolds.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The combine steps of the above pseudo code is different from how most of the executors in JuliaFolds execute FLoops.jl.  Typically, the combine steps are executed in parallel; i.e., they use a more tree-like fashion to provide a greater amount of <a href="https://www.cprogramming.com/parallelism.html"><em>parallelism</em></a>.</p></div></div><p>Only the variables available &quot;after&quot; the <code>for</code> loop (but not the variables local to the loop body) can be used as the arguments to <code>@combine</code>.  Typically, it means the symbols specified by <code>@init</code>.  However, it is possible to introduce new variables for <code>@combine</code> by placing the code introducing new variables after the <code>for</code> loop (see <a href="#simple-completebasecase">Executing code at the end of basecase</a>).  Note also that <code>@init</code>&#39;ed variables do not have to be <code>@combine</code>d.  For example, <code>@init</code> can be used for allocating local buffer for intermediate computation (See: <a href="#local-buffer">Local buffers using <code>@init</code></a>).</p><h2 id="Advanced:-Understanding-@combine-in-terms-of-mapreduce"><a class="docs-heading-anchor" href="#Advanced:-Understanding-@combine-in-terms-of-mapreduce">Advanced: Understanding <code>@combine</code> in terms of <code>mapreduce</code></a><a id="Advanced:-Understanding-@combine-in-terms-of-mapreduce-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced:-Understanding-@combine-in-terms-of-mapreduce" title="Permalink"></a></h2><p>Alternatively, a more concise way to understand <code>@floop</code> and <code>@combine</code> is to conceptualized it as a lowering to a call to <code>mapreduce</code>:</p><pre><code class="language-julia hljs">function basecase(pidigitsᵢ)
    local hist = zeros(Int, 10)   # (1) initialization
    for char in pidigitsᵢ         # (2) basecase
        n = char - &#39;0&#39;
        hist[n+1] += 1
    end
    return hist
end

function combine!(hist, hist′)
    hist .= hist .+ hist′         # (3) combine the sub-solutions
    return hist
end

hist = mapreduce(basecase, combine!, chunks)</code></pre><p>where <code>mapreduce</code> is a parallel implementation of <code>Base.mapreduce</code> (e.g., <code>Folds.mapreduce</code>). Although this picture still does not reflect the actual internal of FLoops.jl (and Transducers.jl), this is a much more accurate mental model than the pseudo code above.</p><h2 id="Advanced:-Unifying-sequential-and-cross-basecase-reductions"><a class="docs-heading-anchor" href="#Advanced:-Unifying-sequential-and-cross-basecase-reductions">Advanced: Unifying sequential and cross-basecase reductions</a><a id="Advanced:-Unifying-sequential-and-cross-basecase-reductions-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced:-Unifying-sequential-and-cross-basecase-reductions" title="Permalink"></a></h2><p>To accumulate numbers into a vector, we can use <code>push!</code> in the basecase and combine the vectors from different basecases using <code>append!</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; @floop begin
           @init odds = Int[]
           @init evens = Int[]
           for x in 1:5
               if isodd(x)
                   push!(odds, x)
               else
                   push!(evens, x)
               end
           end
           @combine odds = append!(odds, _)
           @combine evens = append!(evens, _)
       end
       (odds, evens)
([1, 3, 5], [2, 4])</code></pre><p>Although this code works without an issue, it is redundant to use <code>push!</code> and <code>append!</code> in this example.  Since <code>push!(xs, x)</code> and <code>append!(xs, [x])</code> are equivalent, these functions are quite similar.  The intermediate value <code>[x]</code> is referred to as a <em>singleton solution</em> because it is the value that would be used if the input collection to the <code>for</code> loop contain only one item.</p><p>Indeed, once we have the singleton solution, we can simplify the above code by using the syntax</p><pre><code class="nohighlight hljs">@reduce acc = op(init, input)</code></pre><p>The expression <code>init</code> in the first argument position specifies how to initialize the reduction result <code>acc</code>.  The expression <code>input</code> specifies the value defined in the loop body which is accumulated into the reduction result <code>acc</code>.  The current accumulation state <code>acc</code> is updated by</p><pre><code class="nohighlight hljs">acc = op(acc, input)</code></pre><p>Using this notation, the above code can be simplified to</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; @floop for x in 1:5
           ys = [x]  # &quot;singleton solution&quot;
           if isodd(x)
               @reduce odds = append!(Int[], ys)
           else
               @reduce evens = append!(Int[], ys)
           end
       end
       (odds, evens)
([1, 3, 5], [2, 4])</code></pre><pre><code class="language-julia-repl hljs">julia&gt; let
           odds = Int[]   # \___  The expression in the first argument is
           evens = Int[]  # /     used for the initialization
           for x in 1:5
               ys = [x]
               if isodd(x)
                   odds = append!(odds, ys)
                   #             -----
                   #             LHS `odds` inserted to the first argument
               else
                   evens = append!(evens, ys)
                   #             -----
                   #             LHS `evens` inserted to the first argument
               end
           end
           (odds, evens)
       end
([1, 3, 5], [2, 4])</code></pre><h3 id="Handling-unknown-element-types"><a class="docs-heading-anchor" href="#Handling-unknown-element-types">Handling unknown element types</a><a id="Handling-unknown-element-types-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-unknown-element-types" title="Permalink"></a></h3><p>In the above code, we assumed that we know the type of the elements that are accumulated into a vector.  However, when writing generic code, it is often impossible to know the element types in advance.  We can use BangBang.jl and MicroCollections.jl to create a vector of items with unknown types in such a way that the compiler can optimize very well.</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; using BangBang  # for `append!!`

julia&gt; using MicroCollections  # for `EmptyVector` and `SingletonVector`

julia&gt; @floop for x in 1:5
           ys = SingletonVector(x)
           if isodd(x)
               @reduce odds = append!!(EmptyVector(), ys)
           else
               @reduce evens = append!!(EmptyVector(), ys)
           end
       end
       (odds, evens)
([1, 3, 5], [2, 4])</code></pre><h3 id="Initialization-with-@reduce(acc-init-op-x)-syntax"><a class="docs-heading-anchor" href="#Initialization-with-@reduce(acc-init-op-x)-syntax">Initialization with <code>@reduce(acc = init op x)</code> syntax</a><a id="Initialization-with-@reduce(acc-init-op-x)-syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization-with-@reduce(acc-init-op-x)-syntax" title="Permalink"></a></h3><p>When <code>op</code> is a binary operator, the infix syntax <code>acc = init op x</code> can also be used:</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; @floop for (x, y) in zip(1:3, 1:2:6)
           a = x + y
           b = x - y
           @reduce(s = 0im + a, t = 0im + b)
       end
       (s, t)
(15 + 0im, -3 + 0im)</code></pre><p><strong>NOTE</strong>: In the above examples, statements like <code>odds = append!!(EmptyVector(), ys)</code> and <code>s = 0im + a</code> are <em>not</em> evaluated for each iteration.  These statements as-is are evaluated only for the first iteration (for each basecase) and then the expressions where the first argument is replaced by the corresponding LHS, i.e., <code>odds = append!!(odds, ys)</code> and <code>s = s + a</code>, are evaluated for the bulk of the loop.</p><h2 id="local-buffer"><a class="docs-heading-anchor" href="#local-buffer">Local buffers using <code>@init</code></a><a id="local-buffer-1"></a><a class="docs-heading-anchor-permalink" href="#local-buffer" title="Permalink"></a></h2><p><code>@init</code> can be used without the reduction syntaxes.  It is useful when some basecase-local buffers are required (for avoiding data races):</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; ys = zeros(5);

julia&gt; @floop begin
           @init buffer = zeros(100)
           for i in 1:5
               buffer .= sin.(i .* range(0, pi; length = length(buffer)))
               ys[i] = sum(buffer)
           end
       end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>@init</code> can also be used inside of the <code>for</code> loop body with the <code>@floop for</code> syntax as in</p><pre><code class="language-julia hljs">@floop for i in 1:5
    @init buffer = zeros(100)
    buffer .= sin.(i .* range(0, pi; length = length(buffer)))
    ys[i] = sum(buffer)
end</code></pre><p>However, <code>@floop begin ... end</code> syntax is recommended.</p></div></div><h2 id="simple-completebasecase"><a class="docs-heading-anchor" href="#simple-completebasecase">Executing code at the end of basecase</a><a id="simple-completebasecase-1"></a><a class="docs-heading-anchor-permalink" href="#simple-completebasecase" title="Permalink"></a></h2><p>On GPU, the reduction result must be an immutable value (and not contain any GC-manged objects).  This is often not a problem since Julia ecosystem has a rich set of tooling for programming with immutable values.  For example, we can use <a href="https://github.com/JuliaArrays/StaticArrays.jl"><code>StaticArrays.SVector</code></a> for a histogram with a small number of bins.  However, indexing update on <code>SVector</code> is very inefficient compared to <code>StaticArrays.MVector</code>.  Thus, it is better to execute the basecase reduction using <code>MVector</code> while the cross-basecase reduction uses <code>SVector</code>.  The transformation from <code>MVector</code> to <code>SVector</code> can be done by inserting the code after the <code>for</code> loop and before the <code>@combine</code> expression.</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; using StaticArrays

julia&gt; pidigits = string(BigFloat(π; precision = 2^20))[3:end];

julia&gt; @floop begin
           @init buf = zero(MVector{10,Int32})
           for char in pidigits
               n = char - &#39;0&#39;
               buf[n+1] += 1
           end
           hist = SVector(buf)
           @combine hist .+= _
       end
       hist
10-element SVector{10, Int32} with indices SOneTo(10):
 31559
 31597
 31392
 31712
 31407
 31835
 31530
 31807
 31469
 31345</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To run this on GPU, specific executor library like FoldsCUDA.jl has to be used.  Furthermore, <code>pidigits</code> has to be transformed into a GPU-compatible format (e.g., <code>CuVector{Int8}</code>).</p></div></div><h2 id="Advanced:-Complex-reduction-with-@reduce()-do-syntax"><a class="docs-heading-anchor" href="#Advanced:-Complex-reduction-with-@reduce()-do-syntax">Advanced: Complex reduction with <code>@reduce() do</code> syntax</a><a id="Advanced:-Complex-reduction-with-@reduce()-do-syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced:-Complex-reduction-with-@reduce()-do-syntax" title="Permalink"></a></h2><p>For more complex reduction, use <code>@reduce() do</code> syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; @floop for (i, v) in pairs([0, 1, 3, 2]), (j, w) in pairs([3, 1, 5])
           d = abs(v - w)
           @reduce() do (dmax = -1; d), (imax = 0; i), (jmax = 0; j)
               if isless(dmax, d)
                   dmax = d
                   imax = i
                   jmax = j
               end
           end
       end
       (dmax, imax, jmax)
(5, 1, 3)</code></pre><p>When reading code with <code>@reduce() do</code>, a quick way to understand it is to mentally comment out the line with <code>@reduce() do</code> and the corresponding <code>end</code>.  To get a full picture, move the initialization parts (in the above example, <code>dmax = -1</code>, <code>imax = 0</code>, and <code>jmax = 0</code>) to outside <code>for</code> loop:</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; let
           dmax = -1  # -+
           imax = 0   #  | initializers
           jmax = 0   # -+
           for (i, v) in pairs([0, 1, 3, 2]), (j, w) in pairs([3, 1, 5])
               d = abs(v - w)
               if isless(dmax, d)  # -+
                   dmax = d        #  | `do` block body
                   imax = i        #  |
                   jmax = j        #  |
               end                 # -+
           end
           (dmax, imax, jmax)
       end
(5, 1, 3)</code></pre><p>This exact transformation is used for defining the sequential basecase.</p><p>Consecutive basecases are combined using the code in the <code>do</code> block body.  That is to say, the accumulation result <code>acc = (dmax, imax, jmax)</code> from a basecase and the accumulation result <code>acc_right = (dmax, imax, jmax)</code> from then next basecase are combined using the following function</p><pre><code class="language-julia hljs">function combine(acc, acc_right)
    (dmax, imax, jmax) = acc  # left variables are bound to left sub-solutions
    (d, i, j) = acc_right     # right variables are bound to right sub-solutions
    if isless(dmax, d)
        dmax = d
        imax = i
        jmax = j
    end
    acc = (dmax, imax, jmax)
    return acc
end</code></pre><p>Note that variables left to <code>;</code> and the variables right to <code>;</code> in the original <code>@reduce() do</code> syntax are grouped into the left argument <code>acc</code> and the right argument <code>acc_right</code>, respectively.  This is why the <code>@reduce() do</code> syntax uses the nonstandard delimiter <code>;</code> for separating the arguments.  That is to say, <code>@reduce() do</code> syntax &quot;transposes&quot; (or &quot;unzips&quot;) the arguments to clarify the correspondence of the left and the right arguments.  In general, the expression</p><pre><code class="language-julia hljs">@reduce() do (acc₁; x₁), (acc₂; x₂), ..., (accₙ; xₙ)
    $expression_updates_accs
end</code></pre><p>generates the combine function</p><pre><code class="language-julia hljs">function combine((acc₁, acc₂, ..., accₙ), (x₁, x₂, ..., xₙ))
    $expression_updates_accs
    return (acc₁, acc₂, ..., accₙ)
end</code></pre><p>(Aside: This also clarifies why <code>@reduce() do</code> doesn&#39;t use the standard argument ordering <code>@reduce() do (acc₁, acc₂, ..., accₙ), (x₁, x₂, ..., xₙ)</code>.  From this expression, it is very hard to tell <code>accᵢ</code> corresponds to <code>xᵢ</code>.)</p><p>Like other <code>@reduce</code> expressions, <code>@reduce() do</code> syntax can be used multiple times in a loop body:</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; @floop for (i, v) in pairs([0, 1, 3, 2])
           y = 2v
           @reduce() do (ymax; y), (imax; i)
               if isless(ymax, y)
                   ymax = y
                   imax = i
               end
           end
           @reduce() do (ymin; y), (imin; i)
               if isless(y, ymin)
                   ymin = y
                   imin = i
               end
           end
       end
       (ymax, imax), (ymin, imin)
((6, 3), (0, 1))</code></pre><p>Since the variables left to <code>;</code> (i.e., <code>ymax</code>, <code>imax</code>, <code>ymin</code>, and <code>imin</code> in the above example) are the &quot;output&quot; variables, they must be unique (otherwise, the computation result is not available outside the loop).  However, the variables right to <code>;</code> (i.e., <code>y</code> and <code>i</code> in the above example) do not have to be unique because multiple reductions can be computed using the same intermediate computation done in the loop body.</p><p>Similar to <code>@reduce() do</code> syntax, there is <code>@combine() do</code> syntax.  This is useful when it is more straightforward to use different code for the basecase and combine steps.</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; function maybe_zero_extend_right!(hist, n)
           l = length(hist)
           if l &lt; n
               resize!(hist, n)
               fill!(view(hist, l+1:n), 0)
           end
       end;

julia&gt; function count_positive_ints(ints, ex = ThreadedEx())
           @floop ex begin
               @init hist = Int[]
               for n in ints
                   n &gt; 0 || continue  # filter out non-positive integers
                   maybe_zero_extend_right!(hist, n)
                   @inbounds hist[n] += 1
               end
               @combine() do (hist; other)
                   n = length(other)
                   maybe_zero_extend_right!(hist, n)
                   @views hist[1:n] .+= other
               end
           end
           return hist
       end;

julia&gt; count_positive_ints([7, 5, 3, 3, 8, 6, 0, 6, 5, 2, 6, 6, 5, 0, 8, 3, 4, 2, 5, 2])
8-element Vector{Int64}:
 0
 3
 3
 1
 4
 4
 1
 2</code></pre><h2 id="Control-flow-syntaxes"><a class="docs-heading-anchor" href="#Control-flow-syntaxes">Control flow syntaxes</a><a id="Control-flow-syntaxes-1"></a><a class="docs-heading-anchor-permalink" href="#Control-flow-syntaxes" title="Permalink"></a></h2><p>Control flow syntaxes such as <code>continue</code>, <code>break</code>, <code>return</code>, and <code>@goto</code> work with parallel loops, provided that they are used outside the <code>@reduce</code> syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; function firstmatch(p, xs; ex = ThreadedEx())
           @floop ex for ix in pairs(xs)
               _i, x = ix
               if p(x)
                   @reduce() do (found = nothing; ix)
                       found = ix
                   end
                   break
               end
           end
           return found  # the *first* pair `i =&gt; x` s.t. `p(x)`
       end;

julia&gt; firstmatch(==(42), 1:10)  # finds nothing

julia&gt; firstmatch(isodd, [0, 2, 1, 1, 1])
3 =&gt; 1</code></pre><h2 id="tutorials-executor"><a class="docs-heading-anchor" href="#tutorials-executor">Executors</a><a id="tutorials-executor-1"></a><a class="docs-heading-anchor-permalink" href="#tutorials-executor" title="Permalink"></a></h2><p><code>@floop</code> takes optional executor argument to specify an execution strategies and the parameters of the strategy:</p><pre><code class="language-julia-repl hljs">julia&gt; using FLoops

julia&gt; function demo(executor)
           @floop executor for x in 1:10
               @reduce(s += x)
           end
           return s
       end;

julia&gt; demo(SequentialEx(simd = Val(true)))
55

julia&gt; demo(ThreadedEx(basesize = 2))
55

julia&gt; demo(DistributedEx(threads_basesize = 2))
55</code></pre><p>This is in particular useful for the trick to <a href="https://juliafolds.github.io/data-parallelism/howto/faq/#set-nthreads-at-run-time">&quot;change&quot; the number of threads without restarting <code>julia</code> using <code>basesize</code> option</a>.</p><p>JuliaFolds provides additional executors:</p><ul><li><a href="https://github.com/JuliaFolds/FoldsThreads.jl">FoldsThreads.jl</a> provides a rich set of thread-based executors.</li><li><a href="https://github.com/JuliaFolds/FoldsCUDA.jl">FoldsCUDA.jl</a> provides <code>CUDAEx</code> for executing the parallel loop on GPU.</li></ul><h2 id="floop-and-mapreduce"><a class="docs-heading-anchor" href="#floop-and-mapreduce">Advanced: Relation to <code>mapreduce</code></a><a id="floop-and-mapreduce-1"></a><a class="docs-heading-anchor-permalink" href="#floop-and-mapreduce" title="Permalink"></a></h2><p>If you know are familar with functional style data parallel API and already know <code>mapreduce(f, op, xs; init)</code> works, it is worth noting that <code>@floop</code> is, <em>as a very rough approximation</em>, a way to invoke <code>acc = mapreduce(f, op, xs; init)</code> with a custom syntax</p><pre><code class="language-julia hljs">@floop for x in xs
    y = f(x)
    @reduce acc = op(init, y)
end</code></pre><p>or</p><pre><code class="language-julia hljs">@floop begin
    @init acc = init
    for x in xs
        y = f(x)
        acc = op(acc, y)
    end
    @combine acc = op(acc, _)
end</code></pre><p>However, as explained above, <code>@floop</code> supports various constructs that are not directly supported by <code>mapreduce</code>.  To fully cover the semantics of <code>@floop</code> in a functional manner, the extended reduction (&quot;fold&quot;) protocol of <a href="https://github.com/JuliaFolds/Transducers.jl">Transducers.jl</a> is required.  In fact, FLoops.jl is simply a syntax sugar for invoking the reductions defined in Transducers.jl.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sequential/">« Sequential loops</a><a class="docs-footer-nextpage" href="../../howto/parallel/">How to do <em>X</em> in parallel? »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Sunday 6 February 2022 09:19">Sunday 6 February 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
